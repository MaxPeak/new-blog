import{a as t,b as l,G as e}from"./framework.299d0cbd.js";const i='{"title":"基础","description":"","frontmatter":{},"headers":[{"level":2,"title":"基础","slug":"基础"},{"level":3,"title":"HTTP 协议","slug":"http-协议"},{"level":3,"title":"HTTP 版本","slug":"http-版本"},{"level":3,"title":"HTTP Method（方法）","slug":"http-method（方法）"},{"level":3,"title":"HTTP Status code（状态码）和 Status text（状态文本）","slug":"http-status-code（状态码）和-status-text（状态文本）"},{"level":3,"title":"HTTP Head (HTTP 头)","slug":"http-head-http-头"},{"level":3,"title":"HTTP Request Body","slug":"http-request-body"},{"level":3,"title":"HTTPS","slug":"https"},{"level":2,"title":"网络协议","slug":"网络协议"},{"level":3,"title":"DNS 协议","slug":"dns-协议"},{"level":3,"title":"IP 协议","slug":"ip-协议"},{"level":3,"title":"TCP 协议","slug":"tcp-协议"},{"level":3,"title":"HTTP 协议","slug":"http-协议-2"},{"level":3,"title":"UDP 协议","slug":"udp-协议"},{"level":3,"title":"TCP 协议","slug":"tcp-协议-2"},{"level":2,"title":"预检请求","slug":"预检请求"},{"level":3,"title":"什么是预检请求","slug":"什么是预检请求"},{"level":3,"title":"为什么要发预检请求","slug":"为什么要发预检请求"},{"level":3,"title":"什么时候发预检请求","slug":"什么时候发预检请求"},{"level":2,"title":"FESTful API","slug":"festful-api"},{"level":3,"title":"请求方式","slug":"请求方式"},{"level":3,"title":"错误处理","slug":"错误处理"},{"level":3,"title":"返回数据","slug":"返回数据"},{"level":3,"title":"对应的 sql","slug":"对应的-sql"},{"level":3,"title":"对应的返回状态码","slug":"对应的返回状态码"},{"level":3,"title":"url 设计","slug":"url-设计"}],"relativePath":"base/http.md","lastUpdated":1611830095976}',a={},r=e('<h2 id="基础"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><h3 id="http-协议"><a class="header-anchor" href="#http-协议" aria-hidden="true">#</a> HTTP 协议</h3><ul><li>HTTP 标准由 IETF 组织制定，跟它相关的标准主要有两份 <ul><li><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener noreferrer">HTTP1.1</a></li><li><a href="https://tools.ietf.org/html/rfc7234" target="_blank" rel="noopener noreferrer">HTTP1.1</a></li></ul></li><li>HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的</li></ul><h3 id="http-版本"><a class="header-anchor" href="#http-版本" aria-hidden="true">#</a> HTTP 版本</h3><ul><li><p>HTTP1.0</p><p>默认是短链接，即请求任何一个资源，都会新开一个链接，也就是每次有要经历三次握手，四次挥手，非常消耗资源</p></li><li><p>HTTP1.1</p><ul><li>持久连接</li><li>请求管道化</li><li>增加缓存处理（新的字段如 cache-control）</li><li>增加 Host 字段、支持断点传输等</li></ul></li><li><p>HTTP2</p><p>HTTP 2 是 HTTP 1.1 的升级版本，你可以查看它的<a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener noreferrer">详情</a></p><ul><li>二进制分帧（不再以文本格式来传输）</li><li>多路复用</li><li>头部压缩</li><li>服务器推送</li><li>流量控制</li><li>请求优先级设置</li><li>应用层的重置连接<div class="tip custom-block"><p class="custom-block-title">TIP</p><p>无论是 HTTP1.0 还是 HTTP1.1 提出了 Pipelining 理论，还是会出现阻塞的情况。从专业的名词上说这种情况，叫做线头阻塞（Head of line blocking）简称：HOLB,HTTP2 解决了线头阻塞的问题（多路复用），并且在一些其他地方也做了优化处理</p></div></li></ul></li><li></li></ul><h3 id="http-method（方法）"><a class="header-anchor" href="#http-method（方法）" aria-hidden="true">#</a> HTTP Method（方法）</h3><ul><li>GET:浏览器通过地址栏访问页面都是 GET 方法</li><li>POST:表单提交产生 POST 方法</li><li>HEAD:跟 GET 类似，只返回请求头，多数由 JavaScript 发起</li><li>PUT:表示添加资源</li><li>DELETE:表示删除资源</li><li>CONNECT:多用于 HTTPS 和 WebSocket</li><li>OPTIONS:一般用于调试，多数线上服务都不支持</li><li>TRACE:一般用于调试，多数线上服务都不支持</li></ul><h3 id="http-status-code（状态码）和-status-text（状态文本）"><a class="header-anchor" href="#http-status-code（状态码）和-status-text（状态文本）" aria-hidden="true">#</a> HTTP Status code（状态码）和 Status text（状态文本）</h3><ul><li><p>1xx 消息</p><p>临时回应，表示客户端请继续</p><p>基本上没遇到过 1xx 开头的状态码</p></li><li><p>2xx 成功</p><p>200 表示请求成功，请求所希望的响应头或数据体将随此响应返回，这是最常见的状态码</p></li><li><p>3xx 重定向</p><p>表示请求的目标有变化，希望客户端进一步处理</p><ul><li>301 永久重定向 一般是在网站已经迁移到新的网址的时候会用</li><li>302 临时重定向 一般是网站或者网页 24—48 小时内临时移动到一个新的位置，这时候就要进行 302 跳转</li><li>304 没有修改 一般是一个页面初次请求时成功后刷新页面再次请求时发生 表示客户端已经有缓存 服务端不再需要发送数据体过来 这是浏览器的缓存优化策略之一</li></ul></li><li><p>4xx 客户端错误</p><ul><li>400 服务器不理解请求的语法 一般是请求参数错误会出现</li><li>401 未授权 表示没有权限访问这接口 一般是做了权限处理的后台管理系统会用得比较多</li><li>403 禁止请求 服务器拒绝了改客户端的请求</li><li>404 未找到 这也是非常常见的一个状态码 比如你请求了服务器没有的页面/接口都会是此状态码</li></ul></li><li><p>5xx 服务端错误</p><ul><li>500 服务器内部错误 一般发现此验证码是因为服务器内部的处理逻辑出现了错误 导致不能正常的返回应该的数据</li><li>503 服务端暂时性错误，可以一会再试</li></ul></li></ul><h3 id="http-head-http-头"><a class="header-anchor" href="#http-head-http-头" aria-hidden="true">#</a> HTTP Head (HTTP 头)</h3><p>HTTP 头可以看作一个键值对。原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一些特殊的 HTTP 头，在 HTTP 标准中，有完整的请求 / 响应头规定</p><ul><li><p>Request Header</p><table><thead><tr><th style="text-align:center;">Request Header</th><th>规定</th></tr></thead><tbody><tr><td style="text-align:center;">Accept</td><td>浏览器端接受的格式</td></tr><tr><td style="text-align:center;">Accept-Encoding</td><td>浏览器端接受的编码方式</td></tr><tr><td style="text-align:center;">Accept-Language</td><td>浏览器端接受的语言，用于服务端国际化支持</td></tr><tr><td style="text-align:center;">Cache-Control</td><td>控制缓存的时效性</td></tr><tr><td style="text-align:center;">Connection</td><td>连接方式，如果是 keep-alive，且服务端支持，则会复用连接</td></tr><tr><td style="text-align:center;">Host</td><td>HTTP 访问使用的域名</td></tr><tr><td style="text-align:center;">If-Modified-Since</td><td>上次访问时的更新时间，如果服务端认为此时间后自己没有更新，则会给出 304 响应</td></tr><tr><td style="text-align:center;">If-None-Match</td><td>次访问时使用的 E-Tag，通常是页面的信息摘要，这个比更改时间更准确一些</td></tr><tr><td style="text-align:center;">User-Agent</td><td>客户端标识</td></tr><tr><td style="text-align:center;">Cookie</td><td>客户端存储的 cookie 信息</td></tr></tbody></table></li><li><p>Response Header</p><table><thead><tr><th style="text-align:center;">Response Header</th><th>规定</th></tr></thead><tbody><tr><td style="text-align:center;">Cache-Control</td><td>控制缓存，用于通知各级缓存保存的时间，例如 max-age=0，表示不缓存</td></tr><tr><td style="text-align:center;">Connection</td><td>连接类型，Keep-Alive 表示复用连接</td></tr><tr><td style="text-align:center;">Content-Encoding</td><td>内容编码方式，通常是 gzip</td></tr><tr><td style="text-align:center;">Content-Length</td><td>内容的长度，有利于浏览器判断内容是否已经结束</td></tr><tr><td style="text-align:center;">Content-Type</td><td>内容类型</td></tr><tr><td style="text-align:center;">Date</td><td>当前的服务器时间</td></tr><tr><td style="text-align:center;">ETag</td><td>页面的信息摘要，用于判断是否需要重新到服务端取回页面</td></tr><tr><td style="text-align:center;">Expires</td><td>过期时间，用于判断下次请求是否需要到服务端取回页面</td></tr><tr><td style="text-align:center;">Keep-Alive</td><td>保持连续不断时需要的一些信息，如 timeout=5，max=100</td></tr><tr><td style="text-align:center;">Last-Modified</td><td>页面上次修改的时间</td></tr><tr><td style="text-align:center;">Server</td><td>服务端软件的类型</td></tr><tr><td style="text-align:center;">Set-Cookie</td><td>设置 cookie，可以存在多个</td></tr><tr><td style="text-align:center;">Via</td><td>服务端的请求链路，对于一些调试场景非常重要</td></tr></tbody></table></li></ul><h3 id="http-request-body"><a class="header-anchor" href="#http-request-body" aria-hidden="true">#</a> HTTP Request Body</h3><p>常见格式</p><ul><li>application/json：json 数据默认是这种格式</li><li>application/x-www-form-urlencoded：form 标签提交默认是这种格式</li><li>multipart/form-data：上传文件默认是这种格式</li><li>text/html：html 字符串默认是这种格式</li></ul><h3 id="https"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h3><ul><li>在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式</li><li>HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改</li><li>HTTPS 的标准也是由 RFC 规定的，你可以查看它的<a href="https://tools.ietf.org/html/rfc2818" target="_blank" rel="noopener noreferrer">详情</a></li><li>HTTPS 是在 HTTP 协议的基础上多加了一层 SSL 协议</li><li>HTTPS 采用的是混合加密，过程如下 <ul><li>用户向 web 服务器发起一个安全连接的请求</li><li>服务器返回经过 CA 认证的数字证书，证书里面包含了服务器的 public key(公钥)</li><li>用户拿到数字证书，用自己浏览器内置的 CA 证书解密得到服务器的 public key</li><li>用户用服务器的 public key 加密一个用于接下来的对称加密算法的密钥，传给 web 服务器</li><li>服务器拿到这个加密的密钥，解密获取密钥，再使用对称加密算法，和用户完成接下来的网络通信</li></ul></li><li>HTTPS 相比 HTTP 更安全 <ul><li>所有信息都是加密传播，黑客无法窃听</li><li>具有校验机制，一旦被篡改，通信双方会立刻发现</li><li>配备身份证书，防止身份被冒充</li></ul></li></ul><h2 id="网络协议"><a class="header-anchor" href="#网络协议" aria-hidden="true">#</a> 网络协议</h2><h3 id="dns-协议"><a class="header-anchor" href="#dns-协议" aria-hidden="true">#</a> DNS 协议</h3><p>基于 UDP 协议，负责把域名解析成 IP</p><h3 id="ip-协议"><a class="header-anchor" href="#ip-协议" aria-hidden="true">#</a> IP 协议</h3><p>IP 协议负责寻址</p><h3 id="tcp-协议"><a class="header-anchor" href="#tcp-协议" aria-hidden="true">#</a> TCP 协议</h3><p>基于 IP 协议，负责数据的完整和有序</p><h3 id="http-协议-2"><a class="header-anchor" href="#http-协议-2" aria-hidden="true">#</a> HTTP 协议</h3><p>基于 TCP 协议，负责应用层</p><h3 id="udp-协议"><a class="header-anchor" href="#udp-协议" aria-hidden="true">#</a> UDP 协议</h3><p>基于 IP 协议，只管发和收，不管数据丢不丢</p><p>适合性能要求高，不在乎丢帧或者包足够小，不用分包的情况</p><ul><li>游戏</li><li>语音聊天</li><li>DNS(包足够小)</li></ul><h3 id="tcp-协议-2"><a class="header-anchor" href="#tcp-协议-2" aria-hidden="true">#</a> TCP 协议</h3><p>传输速度快，一般用户内部大文件传输</p><h2 id="预检请求"><a class="header-anchor" href="#预检请求" aria-hidden="true">#</a> 预检请求</h2><h3 id="什么是预检请求"><a class="header-anchor" href="#什么是预检请求" aria-hidden="true">#</a> 什么是预检请求</h3><p>在正常请求前先发送一个 options 的预检请求</p><h3 id="为什么要发预检请求"><a class="header-anchor" href="#为什么要发预检请求" aria-hidden="true">#</a> 为什么要发预检请求</h3><p>因为同源策略的原因，浏览器会限制从脚本发起的跨域 http 请求，一般我们开发中会遇到，浏览器限制跨域的方式有两种：</p><ul><li>浏览器限制发起跨域请求</li><li>跨域请求可以正常发起，但是返回的结果被浏览器拦截了</li></ul><p>一般浏览器都是第二种方式限制跨域请求，那就是说请求已到达服务器，并有可能对数据库里的数据进行了操作，但是返回的结果被浏览器拦截了，那么我们就获取不到返回结果，这是一次失败的请求，但是可能对数据库里的数据产生了影响。为了防止这种情况的发生，规范要求，对这种可能对服务器数据产生副作用的 HTTP 请求方法，浏览器必须先使用 OPTIONS 方法发起一个预检请求，从而获知服务器是否允许该跨域请求：如果允许，就发送带数据的真实请求；如果不允许，则阻止发送带数据的真实请求</p><h3 id="什么时候发预检请求"><a class="header-anchor" href="#什么时候发预检请求" aria-hidden="true">#</a> 什么时候发预检请求</h3><h4 id="简单请求"><a class="header-anchor" href="#简单请求" aria-hidden="true">#</a> 简单请求</h4><ul><li><p>GET</p></li><li><p>DEAD</p></li><li><p>POST</p><p>Content-Type 值为下列之一时</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li></ul><h4 id="需要预检的请求"><a class="header-anchor" href="#需要预检的请求" aria-hidden="true">#</a> 需要预检的请求</h4><p>“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务区，以获知服务器是否允许该实际请求。“预检请求”的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。当请求满足下述任一条件时，即应首先发送预检请求：</p><ul><li>使用了下面任一 HTTP 方法: <ul><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ul></li><li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为: <ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li><li>Content-Type 的值不属于下列之一： <ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li></ul></li></ul><h2 id="festful-api"><a class="header-anchor" href="#festful-api" aria-hidden="true">#</a> FESTful API</h2><p>一套 api 的设计规范，主要是为了保证一套接口多端调用，语义化好</p><h3 id="请求方式"><a class="header-anchor" href="#请求方式" aria-hidden="true">#</a> 请求方式</h3><ul><li>get：查询</li><li>post：新增</li><li>delete：删除</li><li>put：修改</li></ul><h3 id="错误处理"><a class="header-anchor" href="#错误处理" aria-hidden="true">#</a> 错误处理</h3><div class="language-js"><pre><code><span class="token punctuation">{</span>\n  err<span class="token operator">:</span> <span class="token string">&quot;errMessage&quot;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="返回数据"><a class="header-anchor" href="#返回数据" aria-hidden="true">#</a> 返回数据</h3><ul><li>get：对应数据</li><li>post：新增的数据</li><li>delete：返回空</li><li>put：修改后的数据</li></ul><h3 id="对应的-sql"><a class="header-anchor" href="#对应的-sql" aria-hidden="true">#</a> 对应的 sql</h3><ul><li>get：SELECT</li><li>post：CREATE</li><li>delete：DELETE</li><li>put：UPDATE</li></ul><h3 id="对应的返回状态码"><a class="header-anchor" href="#对应的返回状态码" aria-hidden="true">#</a> 对应的返回状态码</h3><ul><li>get <ul><li>200：服务器成功返回用户请求的数据</li></ul></li><li>post <ul><li>201：用户新建成功</li><li>400：用户请求错误，没有新建成功</li><li>422：创建对象时发生了一个错误验证</li></ul></li><li>delete <ul><li>204 删除成功</li></ul></li><li>put <ul><li>201：用户修改成功</li><li>400：用户请求错误，没有修改成功</li><li>422：修改对象时发生了一个错误验证</li></ul></li></ul><h3 id="url-设计"><a class="header-anchor" href="#url-设计" aria-hidden="true">#</a> url 设计</h3><blockquote><p>动词+宾语</p></blockquote><ul><li>动词：就是请求方式 get/post/delete/put</li><li>宾语：就是请求方式和后面的 url 路径，一般是名词，尽量不使用动词</li></ul>',60);a.render=function(e,i,a,d,h,s){return t(),l("div",null,[r])};export default a;export{i as __pageData};
