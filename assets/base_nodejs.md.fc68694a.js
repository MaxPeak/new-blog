import{o as e,c as a,b as l}from"./app.78d90085.js";const n='{"title":"NodeJs 是什么","description":"","frontmatter":{},"headers":[{"level":2,"title":"NodeJs 是什么","slug":"nodejs-是什么"},{"level":2,"title":"优点","slug":"优点"},{"level":2,"title":"缺点","slug":"缺点"},{"level":2,"title":"事件循环","slug":"事件循环"},{"level":3,"title":"libuv 引擎的 6 个阶段","slug":"libuv-引擎的-6-个阶段"},{"level":3,"title":"宏任务（macrotask）","slug":"宏任务（macrotask）"},{"level":3,"title":"微任务（microtask）","slug":"微任务（microtask）"},{"level":3,"title":"其他","slug":"其他"},{"level":2,"title":"模块机制","slug":"模块机制"},{"level":3,"title":"导入","slug":"导入"},{"level":3,"title":"导出","slug":"导出"},{"level":2,"title":"npm","slug":"npm"},{"level":3,"title":"常用指令","slug":"常用指令"},{"level":3,"title":"上传包","slug":"上传包"},{"level":3,"title":"更新包","slug":"更新包"},{"level":3,"title":"删除包","slug":"删除包"},{"level":3,"title":"npx","slug":"npx"},{"level":3,"title":"npm init","slug":"npm-init"},{"level":3,"title":"如何写脚手架","slug":"如何写脚手架"},{"level":2,"title":"常用的几个全局变量","slug":"常用的几个全局变量"}],"relativePath":"base/nodejs.md","lastUpdated":1611877645937}',s={},i=l('<h2 id="nodejs-是什么"><a class="header-anchor" href="#nodejs-是什么" aria-hidden="true">#</a> NodeJs 是什么</h2><ul><li>它是一个 Javascript 运行环境</li><li>依赖于 Chrome V8 引擎进行代码解释</li><li>事件驱动</li><li>非阻塞 I/O</li><li>轻量、可伸缩，适于实时数据交互应用</li><li>单进程，单线程</li></ul><h2 id="优点"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h2><ul><li>高并发（最重要的优点）</li><li>适合 I/O 密集型应用</li></ul><h2 id="缺点"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h2><ul><li>不适合 CPU 密集型应用</li><li>只支持单核 CPU，不能充分利用 CPU</li></ul><h2 id="事件循环"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h2><p>node11 之前运行机制不同于<a href="./js.html#事件循环">浏览器环境</a></p><h3 id="libuv-引擎的-6-个阶段"><a class="header-anchor" href="#libuv-引擎的-6-个阶段" aria-hidden="true">#</a> libuv 引擎的 6 个阶段</h3><ul><li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li><li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li>idle, prepare 阶段：仅 node 内部使用</li><li>poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close 事件回调</li></ul><h3 id="宏任务（macrotask）"><a class="header-anchor" href="#宏任务（macrotask）" aria-hidden="true">#</a> 宏任务（macrotask）</h3><ul><li>script 整体代码</li><li>setTimeout/setInterval</li><li>setImmediate</li><li>I/O 操作</li></ul><h3 id="微任务（microtask）"><a class="header-anchor" href="#微任务（microtask）" aria-hidden="true">#</a> 微任务（microtask）</h3><ul><li>process.nextTick</li><li>promise</li></ul><h3 id="其他"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3><ul><li>process.nextTick 独立在 event loop 之外，它有自己的队列，它优先于微任务队列</li><li>执行时机：microtask 在事件循环的各个阶段之间执行</li><li>node11 之后执行时机和浏览器一致了！</li></ul><h2 id="模块机制"><a class="header-anchor" href="#模块机制" aria-hidden="true">#</a> 模块机制</h2><p>导出导出遵从 CommonJS 规范（运行时加载）</p><h3 id="导入"><a class="header-anchor" href="#导入" aria-hidden="true">#</a> 导入</h3><div class="language-js"><pre><code><span class="token comment">// 运行时执行</span>\n<span class="token comment">// 导出的可以是任何的 js 数据类型</span>\n\n<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="导出"><a class="header-anchor" href="#导出" aria-hidden="true">#</a> 导出</h3><div class="language-js"><pre><code><span class="token comment">// 导出的值会被缓存</span>\n<span class="token comment">// 导出的是一个值得拷贝</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nexports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// export和module.exports的区别</span>\n<span class="token comment">// require执行寻找的是其他模块的module.exports这个属性，值默认为{}</span>\n<span class="token comment">// exports是module.exports这个属性的简写形式，相当于global.exports = module.exports(对象引用关系)</span>\n<span class="token comment">// 所以在导出时用exports简写形式时不能直接等号赋值，只能用.去扩展，而用module.exports可以直接等号赋值也可以用.扩展</span>\n<span class="token comment">// 大多数情况建议用module.exports，这样会减少不必要的麻烦</span>\n</code></pre></div><h2 id="npm"><a class="header-anchor" href="#npm" aria-hidden="true">#</a> npm</h2><h3 id="常用指令"><a class="header-anchor" href="#常用指令" aria-hidden="true">#</a> 常用指令</h3><ul><li><code>-g</code> 全局安装</li><li><code>--save</code> 安装的模块在 dependencies 里面 (简写 npm -S)</li><li><code>--save-dev</code> 安装的模块在 devDependencies 里面(简写 npm -D)</li><li><code>-y</code> 默认全部确定，一般在 init 的时候使用</li><li><code>npm init</code> 初始化项目环境</li><li><code>npm install</code> 下载安装模块 (简写 npm i)</li><li><code>npm uninstall</code> 删除模块</li></ul><h3 id="上传包"><a class="header-anchor" href="#上传包" aria-hidden="true">#</a> 上传包</h3><p>在 npm 官网需要有一个账号</p><ul><li><p>在本地创建模块文件夹</p></li><li><p>初始化项目环境 <code>npm init</code></p></li><li><p>编写代码</p></li><li><p>修改<code>package.json</code>文件</p><ul><li>name:包名字（起名时不要有与 npm 里面有重复）</li><li>version：包版本，x.x.x 的格式，符合语义化版本规则</li><li>description：描述信息</li><li>bin：执行脚本的软连接，写脚手架需要用到</li><li>main：项目入口地址（CommonJS 规范）</li><li>module：项目入口地址（es6 规范）</li><li>types：ts 类型文件申明</li><li>scripts：指定了运行脚本命令的 npm 命令行缩写，默认是空的 test</li><li>keywords：包的关键词，便于 npm 检索</li><li>author：作者信息，一般提供 github 地址</li><li>license: 许可证，默认是 ISC、有的默认是 MIT</li><li>files：包含在项目中的文件(夹)数组，可以声明一个.gitignore 来忽略部分文件</li><li>repository：项目代码仓库地址</li><li>homepage: 项目主页 url，（包的官网）</li><li>config：字段用于添加命令行的环境变量</li><li>dependencies：在生产环境中需要用到的依赖</li><li>devDependencies：在开发、测试环境中用到的依赖</li></ul></li><li><p>在控制台输入 <code>npm login</code> 进行登录（用户名，密码，邮箱）</p></li><li><p>上传你的模块 <code>npm publish</code></p></li></ul><h3 id="更新包"><a class="header-anchor" href="#更新包" aria-hidden="true">#</a> 更新包</h3><ul><li>修改<code>package.json</code>的版本号</li><li>上传你的模块 <code>npm publish</code></li></ul><h3 id="删除包"><a class="header-anchor" href="#删除包" aria-hidden="true">#</a> 删除包</h3><ul><li><code>npm unpublish -f</code> 包名</li></ul><h3 id="npx"><a class="header-anchor" href="#npx" aria-hidden="true">#</a> npx</h3><p>npm5.2 之后新增了 npx 命令，其目的是为了避免全局安装一些模块，比如 create-react-app，以前使用需要-g 全局安装，使用 npx 模块就不需要全局安装，直接<code>npx create-react-app projectName</code>就可以了，在执行 npx 的时候，会将 create-react-app 下载到一个临时目录，使用以后再删除，这样既能保持本地全局模块的干净，也能保证每次都是最新的 cli 版本</p><ul><li><code>npx @vue/cli create projectName</code></li><li><code>npx create-react-app projectName</code></li></ul><h3 id="npm-init"><a class="header-anchor" href="#npm-init" aria-hidden="true">#</a> npm init</h3><p>npm6.1 之后增加的一个更加方便得快捷使用 cli 的命令，简单来说就是你执行 <code>npm init thinkjs</code> 的话 npm 会补全模块名为 <code>create-thinkjs</code> 并执行 <code>npx create-thinkjs</code>，vite 就是这样做的，<code>npm init @vitejs/app projectName</code>相当于<code>npx create-vite-app projectName</code></p><h3 id="如何写脚手架"><a class="header-anchor" href="#如何写脚手架" aria-hidden="true">#</a> 如何写脚手架</h3><div class="language-json"><pre><code><span class="token comment">// package.json</span>\n<span class="token property">&quot;bin&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token property">&quot;vue&quot;</span><span class="token operator">:</span> <span class="token string">&quot;bin/vue.js&quot;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// bin/vue.js</span>\n\n<span class="token comment">// 这句话必须加，为了保证不同电脑的node路径一致，并且必须是文件开头第一行</span>\n#<span class="token operator">!</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>env node\n\n<span class="token comment">// code...</span>\n</code></pre></div><h2 id="常用的几个全局变量"><a class="header-anchor" href="#常用的几个全局变量" aria-hidden="true">#</a> 常用的几个全局变量</h2><ul><li>__dirname：当前执行脚本所在目录</li><li>__filename：当前执行脚本的文件名</li><li>process：进程状态对象 <ul><li>process.argv：命令行参数集合</li><li>process.<wbr>env：环境变量</li></ul></li></ul>',42);s.render=function(l,n,s,t,o,p){return e(),a("div",null,[i])};export default s;export{n as __pageData};
