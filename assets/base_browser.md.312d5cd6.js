import{a as l,b as n,h as e,f as u}from"./framework.299d0cbd.js";const t='{"title":"基础","description":"","frontmatter":{},"headers":[{"level":2,"title":"基础","slug":"基础"},{"level":3,"title":"解析代码","slug":"解析代码"},{"level":3,"title":"构建 DOM 树","slug":"构建-dom-树"},{"level":3,"title":"渲染","slug":"渲染"},{"level":3,"title":"合成","slug":"合成"},{"level":3,"title":"绘制","slug":"绘制"},{"level":2,"title":"BOM","slug":"bom"},{"level":2,"title":"DOM","slug":"dom"},{"level":3,"title":"Node","slug":"node"},{"level":3,"title":"事件","slug":"事件"},{"level":3,"title":"Range","slug":"range"},{"level":3,"title":"遍历","slug":"遍历"},{"level":3,"title":"命名空间","slug":"命名空间"},{"level":2,"title":"CSSOM","slug":"cssom"},{"level":3,"title":"Rules 类型","slug":"rules-类型"},{"level":3,"title":"CSSOM View","slug":"cssom-view"},{"level":2,"title":"输入 url 到页面渲染中间发生了什么","slug":"输入-url-到页面渲染中间发生了什么"},{"level":3,"title":"一、查找域名对应的 ip，找到服务器（DNS 域名解析）","slug":"一、查找域名对应的-ip，找到服务器（dns-域名解析）"},{"level":3,"title":"二、根据 ip 连接对应的服务器 tcp/ip 协议(三次握手，四次挥手)","slug":"二、根据-ip-连接对应的服务器-tcp-ip-协议-三次握手，四次挥手"},{"level":3,"title":"三、服务器处理请求","slug":"三、服务器处理请求"},{"level":3,"title":"四、服务器返回给浏览器对应的响应结果","slug":"四、服务器返回给浏览器对应的响应结果"},{"level":3,"title":"五、浏览器渲染","slug":"五、浏览器渲染"},{"level":3,"title":"回流与重绘","slug":"回流与重绘"}],"relativePath":"base/browser.md","lastUpdated":1611830095976}',i={},a=e("h2",{id:"基础"},[e("a",{class:"header-anchor",href:"#基础","aria-hidden":"true"},"#"),u(" 基础")],-1),s=e("h3",{id:"解析代码"},[e("a",{class:"header-anchor",href:"#解析代码","aria-hidden":"true"},"#"),u(" 解析代码")],-1),o=e("ul",null,[e("li",null,[e("p",null,"词（token）是如何被拆分的"),e("div",{class:"language-html"},[e("pre",null,[e("code",null,[e("span",{class:"token tag"},[e("span",{class:"token tag"},[e("span",{class:"token punctuation"},"<"),u("p")]),u(),e("span",{class:"token attr-name"},"class"),e("span",{class:"token attr-value"},[e("span",{class:"token punctuation attr-equals"},"="),e("span",{class:"token punctuation"},'"'),u("a"),e("span",{class:"token punctuation"},'"')]),e("span",{class:"token punctuation"},">")]),u("text text text"),e("span",{class:"token tag"},[e("span",{class:"token tag"},[e("span",{class:"token punctuation"},"</"),u("p")]),e("span",{class:"token punctuation"},">")]),u("\n")])])]),e("p",null,"解析成 token 大概是这样"),e("ul",null,[e("li",null,"<p“标签开始”的开始"),e("li",null,"class=“a” 属性"),e("li",null,"> “标签开始”的结束"),e("li",null,"text text text 文本"),e("li",null,"</p> 标签结束")]),e("p",null,"实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟“当前状态”有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词（token），最常见的方案就是使用状态机")]),e("li",null,[e("p",null,"状态机"),e("ul",null,[e("li",null,"绝大多数语言的词法部分都是用状态机实现的"),e("li",null,[e("a",{href:"https://html.spec.whatwg.org/multipage/parsing.html#tokenization",target:"_blank",rel:"noopener noreferrer"},"HTML 官方文档")]),e("li",null,"通过状态机，把字符流拆成 token 了")])])],-1),r=e("h3",{id:"构建-dom-树"},[e("a",{class:"header-anchor",href:"#构建-dom-树","aria-hidden":"true"},"#"),u(" 构建 DOM 树")],-1),c=e("ul",null,[e("li",null,[e("a",{href:"https://html.spec.whatwg.org/multipage/parsing.html#tree-construction",target:"_blank",rel:"noopener noreferrer"},"HTML 的解析规则")]),e("li",null,[u("构建过程 "),e("ul",null,[e("li",null,"浏览器会尽量流式处理整个过程"),e("li",null,"从父到子，从先到后，一个一个节点构建"),e("li",null,"解析 css 的选择器规则，匹配对应的 dom"),e("li",null,"把不含样式信息的 DOM 树应用 css 规则，变成包含样式信息的 DOM 树，并且根据样式信息，计算元素的位置和大小")])])],-1),p=e("h3",{id:"渲染"},[e("a",{class:"header-anchor",href:"#渲染","aria-hidden":"true"},"#"),u(" 渲染")],-1),d=e("ul",null,[e("li",null,[e("p",null,"把模型变成位图的过程")]),e("li",null,[e("p",null,"这里的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染")])],-1),h=e("h3",{id:"合成"},[e("a",{class:"header-anchor",href:"#合成","aria-hidden":"true"},"#"),u(" 合成")],-1),m=e("ul",null,[e("li",null,"渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面。")],-1),g=e("h3",{id:"绘制"},[e("a",{class:"header-anchor",href:"#绘制","aria-hidden":"true"},"#"),u(" 绘制")],-1),S=e("ul",null,[e("li",null,[e("p",null,"绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可")]),e("li",null,[e("p",null,"一般最终位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者驱动就可以了，这取决于浏览器运行的环境。不过无论如何，我们把任何位图合成到这个“最终位图”的操作称为绘制")]),e("li",null,[e("p",null,"计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域")]),e("li",null,[e("p",null,"设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂")])],-1),k=e("h2",{id:"bom"},[e("a",{class:"header-anchor",href:"#bom","aria-hidden":"true"},"#"),u(" BOM")],-1),N=e("p",null,"浏览器的 API 非常的多，这里只列举常用的",-1),v=e("ul",null,[e("li",null,"location：导航栏位置信息"),e("li",null,"history：导航栏历史信息"),e("li",null,"navigator：浏览器的信息"),e("li",null,[u("Storage：本地存储 "),e("ul",null,[e("li",null,"大小：小于 5M"),e("li",null,"localstorage：永久存在"),e("li",null,"sessionStorage：关闭标签页或者窗口删除"),e("li",null,"同源")])]),e("li",null,[u("IndexedDB：浏览器自带的事务型数据库系统 "),e("ul",null,[e("li",null,[u("大小 "),e("ul",null,[e("li",null,"全局限制：自己电脑硬盘的 50%"),e("li",null,"组限制：全局限制的 20%")])]),e("li",null,"永久存在"),e("li",null,"同源")])]),e("li",null,[u("Cookie "),e("ul",null,[e("li",null,"大小：小于 4KB"),e("li",null,"数量小于 20 个"),e("li",null,"有效期为设置的值"),e("li",null,"同源")])])],-1),A=e("h2",{id:"dom"},[e("a",{class:"header-anchor",href:"#dom","aria-hidden":"true"},"#"),u(" DOM")],-1),C=e("h3",{id:"node"},[e("a",{class:"header-anchor",href:"#node","aria-hidden":"true"},"#"),u(" Node")],-1),b=e("ul",null,[e("li",null,[e("p",null,[u("Node 是 DOM 树继承关系的根节点，它定义了 DOM 节点在 DOM 树上的操作 "),e("img",{src:"/Node.png",alt:"Node关系图"})])]),e("li",null,[e("p",null,"表示在 DOM 树中的关系的 API"),e("ul",null,[e("li",null,"parentNode"),e("li",null,"childNodes"),e("li",null,"firstChild"),e("li",null,"lastChild"),e("li",null,"nextSibling"),e("li",null,"previousSibling")])]),e("li",null,[e("p",null,"操作 DOM 的 API"),e("ul",null,[e("li",null,"appendChild"),e("li",null,"insertBefore"),e("li",null,"removeChild"),e("li",null,"replaceChild")])]),e("li",null,[e("p",null,"高级 API"),e("ul",null,[e("li",null,"compareDocumentPosition 是一个用于比较两个节点中关系的函数"),e("li",null,"contains 检查一个节点是否包含另一个节点的函数"),e("li",null,"isEqualNode 检查两个节点是否完全相同"),e("li",null,"isSameNode 检查两个节点是否是同一个节点，实际上在 JavaScript 中可以用“===”"),e("li",null,"cloneNode 复制一个节点，如果传入参数 true，则会连同子元素做深拷贝")])]),e("li",null,[e("p",null,"创建节点的 API"),e("ul",null,[e("li",null,"createElement"),e("li",null,"createTextNode"),e("li",null,"createCDATASection"),e("li",null,"createComment"),e("li",null,"createProcessingInstruction"),e("li",null,"createDocumentFragment"),e("li",null,"createDocumentType")])]),e("li",null,[e("p",null,"操作 Node 属性 API"),e("ul",null,[e("li",null,"getAttribute"),e("li",null,"setAttribute"),e("li",null,"removeAttribute"),e("li",null,"hasAttribute")])]),e("li",null,[e("p",null,"如果你追求极致的性能，还可以把 Attribute 当作节点"),e("ul",null,[e("li",null,"getAttributeNode"),e("li",null,"setAttributeNode")])]),e("li",null,[e("p",null,"查找元素 API"),e("ul",null,[e("li",null,"querySelector"),e("li",null,"querySelectorAll"),e("li",null,"getElementById"),e("li",null,"getElementsByName"),e("li",null,"getElementsByTagName"),e("li",null,[u("getElementsByClassName"),e("div",{class:"tip custom-block"},[e("p",{class:"custom-block-title"},"TIP"),e("p",null,"1、getElementById、getElementsByName、getElementsByTagName、getElementsByClassName，这几个 API 的性能高于 querySelector"),e("p",null,"2、getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，而是一个能够动态更新的集合")])])])])],-1),f=e("h3",{id:"事件"},[e("a",{class:"header-anchor",href:"#事件","aria-hidden":"true"},"#"),u(" 事件")],-1),M=e("div",{class:"tip custom-block"},[e("p",{class:"custom-block-title"},"TIP"),e("p",null,"概述"),e("p",null,"事件来自输入设备，我们平时的个人设备上，输入设备有三种：键盘、鼠标、触摸屏"),e("p",null,"这其中，触摸屏和鼠标又有一定的共性，它们被称作 pointer 设备，所谓 pointer 设备，是指它的输入最终会被抽象成屏幕上面的一个点。但是触摸屏和鼠标又有一定区别，它们的精度、反应时间和支持的点的数量都不一样"),e("p",null,"我们认为我们能够“点击一个按钮”，实际上并非如此，我们只能够点击鼠标上的按钮或者触摸屏，是操作系统和浏览器把这个信息对应到了一个逻辑上的按钮，再使得它的视图对点击事件有反应，这就是捕获与冒泡"),e("p",null,"pointer 事件是由坐标控制，而键盘事件则由焦点系统控制"),e("p",null,"焦点系统也是视障用户访问的重要入口，所以设计合理的焦点系统是非常重要的产品需求，尤其是不少国家对可访问性有明确的法律要求")],-1),y=e("ul",null,[e("li",null,[e("p",null,"捕获与冒泡"),e("ul",null,[e("li",null,"捕获：从外向内"),e("li",null,"冒泡：从内而外")])]),e("li",null,[e("p",null,"自定义事件"),e("div",{class:"language-"},[e("pre",null,[e("code",null,'var evt = new Event("look", {"bubbles":true, "cancelable":false});\ndocument.dispatchEvent(evt);\n')])])]),e("li",null,[e("p",null,[e("a",{href:"https://developer.mozilla.org/zh-CN/docs/Web/Events",target:"_blank",rel:"noopener noreferrer"},"事件分类")])])],-1),I=e("h3",{id:"range"},[e("a",{class:"header-anchor",href:"#range","aria-hidden":"true"},"#"),u(" Range")],-1),P=e("ul",null,[e("li",null,"Range API 是一个比较专业的领域，如果不做富文本编辑类的业务，不需要太深入"),e("li",null,"Range API 表示一个 HTML 上的范围，这个范围是以文字为最小单位的，所以 Range 不一定包含完整的节点，它可能是 Text 节点中的一段，也可以是头尾两个 Text 的一部分加上中间的元素"),e("li",null,"我们通过 Range API 可以比节点 API 更精确地操作 DOM 树，凡是 节点 API 能做到的，Range API 都可以做到，而且可以做到更高性能，但是 Range API 使用起来比较麻烦，所以在实际项目中，并不常用，只有做底层框架和富文本编辑对它有强需求")],-1),T=e("h3",{id:"遍历"},[e("a",{class:"header-anchor",href:"#遍历","aria-hidden":"true"},"#"),u(" 遍历")],-1),O=e("ul",null,[e("li",null,"NodeIterator"),e("li",null,"TreeWalker")],-1),D=e("h3",{id:"命名空间"},[e("a",{class:"header-anchor",href:"#命名空间","aria-hidden":"true"},"#"),u(" 命名空间")],-1),B=e("ul",null,[e("li",null,"在 HTML 场景中，需要考虑命名空间的场景不多。最主要的场景是 SVG。创建元素和属性相关的 API 都有带命名空间的版本"),e("li",null,[u("document "),e("ul",null,[e("li",null,"createElementNS"),e("li",null,"createAttributeNS")])]),e("li",null,[u("Element "),e("ul",null,[e("li",null,"getAttributeNS"),e("li",null,"setAttributeNS"),e("li",null,"getAttributeNodeNS"),e("li",null,"setAttributeNodeNS"),e("li",null,"removeAttributeNS"),e("li",null,"hasAttributeNS"),e("li",null,"attributes.setNamedItemNS"),e("li",null,"attributes.getNamedItemNS"),e("li",null,"attributes.removeNamedItemNS")])]),e("li",null,[u("若要创建 Document 或者 Doctype，也必须要考虑命名空间问题。DOM 要求从 document.implementation 来创建 "),e("ul",null,[e("li",null,"document.implementation.createDocument"),e("li",null,"document.implementation.createDocumentType")])])],-1),R=e("h2",{id:"cssom"},[e("a",{class:"header-anchor",href:"#cssom","aria-hidden":"true"},"#"),u(" CSSOM")],-1),w=e("div",{class:"language-js"},[e("pre",null,[e("code",null,[e("span",{class:"token comment"},"// 获取样式表"),u("\ndocument"),e("span",{class:"token punctuation"},"."),u("styleSheets"),e("span",{class:"token punctuation"},";"),u("\n\n"),e("span",{class:"token comment"},"// 插入规则"),u("\ndocument"),e("span",{class:"token punctuation"},"."),u("styleSheets"),e("span",{class:"token punctuation"},"["),e("span",{class:"token number"},"0"),e("span",{class:"token punctuation"},"]"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"insertRule"),e("span",{class:"token punctuation"},"("),e("span",{class:"token string"},'"p { color:pink; }"'),e("span",{class:"token punctuation"},","),u(),e("span",{class:"token number"},"0"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),u("\n\n"),e("span",{class:"token comment"},"// 删除规则"),u("\ndocument"),e("span",{class:"token punctuation"},"."),u("styleSheets"),e("span",{class:"token punctuation"},"["),e("span",{class:"token number"},"0"),e("span",{class:"token punctuation"},"]"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"removeRule"),e("span",{class:"token punctuation"},"("),e("span",{class:"token number"},"0"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),u("\n\n"),e("span",{class:"token comment"},"// 获取特定的规则"),u("\ndocument"),e("span",{class:"token punctuation"},"."),u("styleSheets"),e("span",{class:"token punctuation"},"["),e("span",{class:"token number"},"0"),e("span",{class:"token punctuation"},"]"),e("span",{class:"token punctuation"},"."),u("cssRules"),e("span",{class:"token punctuation"},";"),u("\n\n"),e("span",{class:"token comment"},"// 获取计算后的样式"),u("\nwindow"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"getComputedStyle"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),u("\n")])])],-1),E=e("h3",{id:"rules-类型"},[e("a",{class:"header-anchor",href:"#rules-类型","aria-hidden":"true"},"#"),u(" Rules 类型")],-1),x=e("ul",null,[e("li",null,"CSSStyleRule"),e("li",null,"CSSCharsetRule"),e("li",null,"CSSImportRule"),e("li",null,"CSSMediaRule"),e("li",null,"CSSFontFaceRule"),e("li",null,"CSSPageRule"),e("li",null,"CSSNamespaceRule"),e("li",null,"CSSKeyframesRule"),e("li",null,"CSSKeyframeRule"),e("li",null,"CSSSupportsRule")],-1),H=e("h3",{id:"cssom-view"},[e("a",{class:"header-anchor",href:"#cssom-view","aria-hidden":"true"},"#"),u(" CSSOM View")],-1),L=e("p",null,"CSSOM View 这一部分的 API，可以视为 DOM API 的扩展，它在原本的 Element 接口上，添加了显示相关的功能，这些功能，又可以分成三个部分",-1),Y=e("h4",{id:"窗口-api"},[e("a",{class:"header-anchor",href:"#窗口-api","aria-hidden":"true"},"#"),u(" 窗口 API")],-1),F=e("ul",null,[e("li",null,"moveTo(x, y) 窗口移动到屏幕的特定坐标"),e("li",null,"moveBy(x, y) 窗口移动特定距离"),e("li",null,"resizeTo(x, y) 改变窗口大小到特定尺寸"),e("li",null,"resizeBy(x, y) 改变窗口大小特定尺寸"),e("li",null,"window.open('url','_blank','windowsize')")],-1),K=e("h4",{id:"滚动-api"},[e("a",{class:"header-anchor",href:"#滚动-api","aria-hidden":"true"},"#"),u(" 滚动 API")],-1),q=e("ul",null,[e("li",null,[u("视图滚动 API "),e("ul",null,[e("li",null,"scrollX"),e("li",null,"scrollY"),e("li",null,"scroll(x, y)"),e("li",null,[u("scrollBy(x, y)"),e("div",{class:"tip custom-block"},[e("p",{class:"custom-block-title"},"TIP"),e("p",null,"大部分移动端浏览器都会采用一些性能优化，它和元素滚动不完全一样")])])])]),e("li",null,[u("元素滚动 API "),e("ul",null,[e("li",null,"scrollTop"),e("li",null,"scrollLeft"),e("li",null,"scrollWidth"),e("li",null,"scrollHeight"),e("li",null,"scroll(x, y)"),e("li",null,"scrollBy(x, y)"),e("li",null,"scrollIntoView(arg)")])])],-1),z=e("h4",{id:"布局-api"},[e("a",{class:"header-anchor",href:"#布局-api","aria-hidden":"true"},"#"),u(" 布局 API")],-1),W=e("ul",null,[e("li",null,[u("全局尺寸信息 "),e("ul",null,[e("li",null,"innerHeight"),e("li",null,"innerWidth"),e("li",null,"outerHeight"),e("li",null,"outerWidth"),e("li",null,"devicePixelRatio"),e("li",null,"screen")])]),e("li",null,[u("元素的布局信息 "),e("ul",null,[e("li",null,"getClientRects()"),e("li",null,"getBoundingClientRect()")])])],-1),V=e("h2",{id:"输入-url-到页面渲染中间发生了什么"},[e("a",{class:"header-anchor",href:"#输入-url-到页面渲染中间发生了什么","aria-hidden":"true"},"#"),u(" 输入 url 到页面渲染中间发生了什么")],-1),_=e("h3",{id:"一、查找域名对应的-ip，找到服务器（dns-域名解析）"},[e("a",{class:"header-anchor",href:"#一、查找域名对应的-ip，找到服务器（dns-域名解析）","aria-hidden":"true"},"#"),u(" 一、查找域名对应的 ip，找到服务器（DNS 域名解析）")],-1),j=e("ul",null,[e("li",null,"1.在浏览器中查找(以谷歌为例，在 chrome://net-internals 里面的 dns 里面去查找域名对应的 ip)"),e("li",null,"2.在电脑系统里面查找(以 windows 系统为例，在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件查找对应 ip)"),e("li",null,"3.在路由器里面查找"),e("li",null,"4.在运营商查找"),e("li",null,"5.根(保存所有 ip 对应关系的服务器)")],-1),U=e("h3",{id:"二、根据-ip-连接对应的服务器-tcp-ip-协议-三次握手，四次挥手"},[e("a",{class:"header-anchor",href:"#二、根据-ip-连接对应的服务器-tcp-ip-协议-三次握手，四次挥手","aria-hidden":"true"},"#"),u(" 二、根据 ip 连接对应的服务器 tcp/ip 协议(三次握手，四次挥手)")],-1),G=e("ul",null,[e("li",null,[u("1.三次握手，所谓的三次握手，是指建立一个 TCP 连接时，需要客户端和服务端总共发送三个包。三次握手的目的是连接服务器指定端口号，建立 TCP 连接，并同步连接双方的序列号和确认号并交接 TCP 窗口大小信息 "),e("ul",null,[e("li",null,"(1)第一次握手：建立连接时，客户端 A 发送 SYN 包（SYN=j）到服务器 B，并进入 SYN_SEND 状态，等待服务器 B 确认"),e("li",null,"(2)第二次握手：服务器 B 收到 SYN 包，必须确认客户 A 的 SYN（ACK=j+1），同时自己也发送一个 SYN 包（SYN=k），即 SYN+ACK 包，此时服务器 B 进入 SYN_RECV 状态"),e("li",null,"(3)第三次握手：客户端 A 收到服务器 B 的 SYN+ACK 包，向服务器 B 发送确认包 ACK（ACK=k+1），此包发送完毕，客户端 A 和服务器 B 进入 ESTABLISHED 状态，完成三次握手")])]),e("li",null,[u("2.四次挥手，TCP 的连接的拆除需要发送四个包，因此称为四次挥手。客户端和服务端均可主动发起挥手动作 "),e("ul",null,[e("li",null,"(1)客户端 A 发送一个 FIN，用来关闭客户端 A 到服务器 B 的数据传送"),e("li",null,"(2)服务器 B 收到 FIN，它发回一个 ACK，确认序号为收到的序号加 1，和 SYN 一样，一个 FIN 将占用一个序号"),e("li",null,"(3)服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A"),e("li",null,[u("(4)客户端 A 收到 FIN，它发回一个 ACK，确认序号为收到的序号加 1，和 SYN 一样，一个 FIN 将占用一个序号"),e("div",{class:"tip custom-block"},[e("p",{class:"custom-block-title"},"TIP"),e("p",null,"因为 TCP 是双全工的，因此每个方向必须单独进行关闭，因此会有四次挥手")])])])])],-1),J=e("h3",{id:"三、服务器处理请求"},[e("a",{class:"header-anchor",href:"#三、服务器处理请求","aria-hidden":"true"},"#"),u(" 三、服务器处理请求")],-1),X=e("ul",null,[e("li",null,"1.静态资源处理，如果浏览器有缓存则使用缓存"),e("li",null,"2.接口请求处理")],-1),Q=e("h3",{id:"四、服务器返回给浏览器对应的响应结果"},[e("a",{class:"header-anchor",href:"#四、服务器返回给浏览器对应的响应结果","aria-hidden":"true"},"#"),u(" 四、服务器返回给浏览器对应的响应结果")],-1),Z=e("ul",null,[e("li",null,"浏览器检测是否跨域，跨域则限制数据接收"),e("li",null,"检测静态资源是否有缓存，没有则写入缓存")],-1),$=e("h3",{id:"五、浏览器渲染"},[e("a",{class:"header-anchor",href:"#五、浏览器渲染","aria-hidden":"true"},"#"),u(" 五、浏览器渲染")],-1),ll=e("ul",null,[e("li",null,[u("1.处理 HTML 标记并构建 DOM 树 "),e("ul",null,[e("li",null,"(1)转换(将字节转换成字符)：浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（如 UTF-8）将它们转换成各个字符"),e("li",null,[u("(2)Tokenizing(确定 tokens)： 浏览器将字符串转换成 W3C HTML5 标准规定的各种 tokens，例如，"),e("code",null,"<html>"),u("、"),e("code",null,"<body>"),u("，以及其他尖括号内的字符串。每个 token 都具有特殊含义和一组规则")]),e("li",null,"(3)词法分析(将 tokens 转换成节点)： 发出的标记转换成定义其属性和规则的“对象”"),e("li",null,[u("(4)DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内 "),e("blockquote",null,[e("p",null,"注意：此时 DOM 树只是捕获文档标记的属性和关系，但并没有告诉我们元素在渲染后呈现的外观，那是 CSSOM 的责任")])])])]),e("li",null,[u("2.处理 CSS 标记并构建 CSSOM 树 "),e("ul",null,[e("li",null,"(1)与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML")])]),e("li",null,[u("3.将 DOM 与 CSSOM 合并成一个渲染树 "),e("ul",null,[e("li",null,"(1)DOM 树与 CSSOM 树合并后形成渲染树，它只包含渲染网页所需的节点。遍历每个 DOM 树中的 node 节点，在 CSSOM 规则树中寻找当前节点的样式，生成渲染树"),e("li",null,"(2)布局计算每个对象的精确位置和大小"),e("li",null,"(3)最后一步是绘制，使用最终渲染树将像素渲染到屏幕上")])]),e("li",null,[u("4.根据渲染树来布局，以计算每个节点的几何信息 "),e("ul",null,[e("li",null,"(1)到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备视口内的确切位置和大小---这就是“布局”阶段，也称为“reflow”"),e("li",null,"(2)为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历"),e("li",null,"(3)布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素"),e("li",null,[u('(4)最后，既然我们知道了哪些节点可见、它们的 computed styles 以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为"painting" or "rasterizing." '),e("blockquote",null,[e("p",null,"注意：执行渲染树构建、布局和绘制所需的时间将取决于文档大小、应用的样式，以及运行文档的设备：文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”）")])])])]),e("li",null,"5.将各个节点绘制到屏幕上"),e("li",null,[u("补充：为构建渲染树，浏览器大体上完成了下列工作： "),e("ul",null,[e("li",null,[u("(1)从 DOM 树的根节点开始遍历每个可见节点 "),e("ul",null,[e("li",null,"① 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略"),e("li",null,"② 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略。例如 span 节点上设置了“display: none”属性，所以也不会出现在渲染树中")])]),e("li",null,"(2)遍历每个可见节点，为其找到适配的 CSSOM 规则并应用它们。从选择器的右边往左边开始匹配，也就是从 CSSOM 树的子节点开始往父节点匹配(这就是为什么 css 选择器没有父级选择器的原因)"),e("li",null,[u("(3)发出带有内容及其计算样式的可见节点 "),e("blockquote",null,[e("p",null,"注意：visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。(这就是为什么 display: none 没有过度效果的原因)")])])])])],-1),nl=e("h3",{id:"回流与重绘"},[e("a",{class:"header-anchor",href:"#回流与重绘","aria-hidden":"true"},"#"),u(" 回流与重绘")],-1),el=e("ul",null,[e("li",null,"当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘"),e("li",null,[u("当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘"),e("div",{class:"tip custom-block"},[e("p",{class:"custom-block-title"},"TIP"),e("p",null,"注意：回流必将引起重绘，而重绘不一定会引起回流。 我们需要明白，页面若发生回流则需要付出很高的代价")])])],-1);i.render=function(e,u,t,i,ul,tl){return l(),n("div",null,[a,s,o,r,c,p,d,h,m,g,S,k,N,v,A,C,b,f,M,y,I,P,T,O,D,B,R,w,E,x,H,L,Y,F,K,q,z,W,V,_,j,U,G,J,X,Q,Z,$,ll,nl,el])};export default i;export{t as __pageData};
