import{o as n,c as t,b as a}from"./app.78d90085.js";const s='{"title":"类型","description":"","frontmatter":{},"headers":[{"level":2,"title":"类型","slug":"类型"},{"level":3,"title":"Undefined","slug":"undefined"},{"level":3,"title":"Null","slug":"null"},{"level":3,"title":"Boolean","slug":"boolean"},{"level":3,"title":"String","slug":"string"},{"level":3,"title":"Number","slug":"number"},{"level":3,"title":"Symbol","slug":"symbol"},{"level":3,"title":"Object","slug":"object"},{"level":3,"title":"BigInt(第三阶段提案)","slug":"bigint-第三阶段提案"},{"level":2,"title":"一些冷知识","slug":"一些冷知识"},{"level":2,"title":"类型转换","slug":"类型转换"},{"level":3,"title":"StringToNumber","slug":"stringtonumber"},{"level":3,"title":"NumberToString","slug":"numbertostring"},{"level":3,"title":"装箱转换","slug":"装箱转换"},{"level":3,"title":"拆箱转换","slug":"拆箱转换"},{"level":3,"title":"typeof","slug":"typeof"},{"level":2,"title":"js 对象的两类属性","slug":"js-对象的两类属性"},{"level":3,"title":"数据属性","slug":"数据属性"},{"level":3,"title":"访问器属性","slug":"访问器属性"},{"level":2,"title":"原型","slug":"原型"},{"level":2,"title":"new 操作符做了那些事","slug":"new-操作符做了那些事"},{"level":2,"title":"js 中对象的分类","slug":"js-中对象的分类"},{"level":3,"title":"宿主对象","slug":"宿主对象"},{"level":3,"title":"内置对象","slug":"内置对象"},{"level":2,"title":"事件循环","slug":"事件循环"},{"level":3,"title":"宏观任务（macrotask）","slug":"宏观任务（macrotask）"},{"level":3,"title":"微观任务（microtask）","slug":"微观任务（microtask）"},{"level":2,"title":"ES 模块机制","slug":"es-模块机制"},{"level":3,"title":"import","slug":"import"},{"level":3,"title":"export","slug":"export"},{"level":3,"title":"复合写法","slug":"复合写法"},{"level":2,"title":"闭包","slug":"闭包"},{"level":2,"title":"执行上下文","slug":"执行上下文"},{"level":3,"title":"ES3","slug":"es3"},{"level":3,"title":"ES5","slug":"es5"},{"level":3,"title":"ES7","slug":"es7"},{"level":2,"title":"控制型语句一些组合行为","slug":"控制型语句一些组合行为"},{"level":2,"title":"JavaScript 的词法定义","slug":"javascript-的词法定义"}],"relativePath":"base/js.md","lastUpdated":1611877645933}',e={},o=a('<h2 id="类型"><a class="header-anchor" href="#类型" aria-hidden="true">#</a> 类型</h2><p>js 的每一个值都是一种类型，根据最新的语言标准，有七种类型和一种提案类型：</p><h3 id="undefined"><a class="header-anchor" href="#undefined" aria-hidden="true">#</a> Undefined</h3><p>用 void 0 来获取 undefined，因为 undefined 是一个变量而并非关键字，是可以被修改的，不过在现代浏览器中是可以安全使用的，因为这一行为在 2009 年的 <a href="https://es5.github.io/#x15.1.1.3" target="_blank" rel="noopener noreferrer">ECMAScript 5</a>被修复了</p><h3 id="null"><a class="header-anchor" href="#null" aria-hidden="true">#</a> Null</h3><p>因为 null 是 Object 的衍生类型，所以在使用<code>typeof null</code>的时候得到的是 object</p><h3 id="boolean"><a class="header-anchor" href="#boolean" aria-hidden="true">#</a> Boolean</h3><h3 id="string"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h3><ul><li>String 有最大长度限制(2^53-1),这个长度不是指字符串长度，而是对应的 <code>Unicode</code> 编码长度</li><li>JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，要格外注意</li></ul><h3 id="number"><a class="header-anchor" href="#number" aria-hidden="true">#</a> Number</h3><ul><li><p>JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值</p></li><li><p>JavaScript 中的 Number 类型采用 IEEE 754-2008 规定的双精度浮点数规则，所以会有两个问题</p><ul><li>进行小数计算会有精度丢失问题，解决办法是把小数转换成整数进行计算得到结果在转换回小数</li><li>超过最大安全数无法正确计算和显示，解决办法是使用第三方库或者是使用 BigInt 数据类型</li></ul></li><li><p>特殊的三个值</p><ul><li>NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字</li><li>Infinity，无穷大</li><li>-Infinity，负无穷大</li></ul></li></ul><h3 id="symbol"><a class="header-anchor" href="#symbol" aria-hidden="true">#</a> Symbol</h3><p>Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑</p><h3 id="object"><a class="header-anchor" href="#object" aria-hidden="true">#</a> Object</h3><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一</p><h3 id="bigint-第三阶段提案"><a class="header-anchor" href="#bigint-第三阶段提案" aria-hidden="true">#</a> BigInt(第三阶段提案)</h3><p>BigInt 是新的数据类型，BigInt 数据类型的目的是比 Number 数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用 BigInt，整数溢出将不再是问题，此外，可以安全地使用更加准确时间戳，大整数 ID 等，而无需使用变通方法</p><h2 id="一些冷知识"><a class="header-anchor" href="#一些冷知识" aria-hidden="true">#</a> 一些冷知识</h2><ul><li>2^53-1 是 js 中的最大安全整数</li><li><code>Symbol.iterator</code> 可以定义 for of 的行为<div class="language-js"><pre><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\no<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> v<span class="token operator">++</span><span class="token punctuation">,</span> done<span class="token operator">:</span> v <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 2 3 4 5...9</span>\n<span class="token punctuation">}</span>\n</code></pre></div></li><li>在对象原型上添加的方法之所以可以在基础类型中使用，是因为<code>.</code>运算符提供了一个装箱操作，它会根据基础类型构造一个临时对象，使我们能在基础类型上调用对应的对象方法</li><li><code>async</code> 函数必定返回 <code>Promise</code></li></ul><h2 id="类型转换"><a class="header-anchor" href="#类型转换" aria-hidden="true">#</a> 类型转换</h2><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">Null</th><th style="text-align:center;">Undefined</th><th style="text-align:center;">Boolean(true)</th><th style="text-align:center;">Boolean(false)</th><th style="text-align:center;">Number</th><th style="text-align:center;">String</th><th style="text-align:center;">Symbol</th><th style="text-align:center;">Object</th></tr></thead><tbody><tr><td style="text-align:center;">Boolean</td><td style="text-align:center;">false</td><td style="text-align:center;">false</td><td style="text-align:center;">-</td><td style="text-align:center;">-</td><td style="text-align:center;">0/NaN-false</td><td style="text-align:center;">&quot;&quot;-false</td><td style="text-align:center;">true</td><td style="text-align:center;">true</td></tr><tr><td style="text-align:center;">Number</td><td style="text-align:center;">0</td><td style="text-align:center;">NaN</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">-</td><td style="text-align:center;">StringToNumber</td><td style="text-align:center;">TypeError</td><td style="text-align:center;">拆箱转换</td></tr><tr><td style="text-align:center;">String</td><td style="text-align:center;">&quot;null&quot;</td><td style="text-align:center;">&quot;undefined&quot;</td><td style="text-align:center;">&quot;true&quot;</td><td style="text-align:center;">&quot;false&quot;</td><td style="text-align:center;">NumberToString</td><td style="text-align:center;">-</td><td style="text-align:center;">TypeError</td><td style="text-align:center;">拆箱转换</td></tr><tr><td style="text-align:center;">Object</td><td style="text-align:center;">TypeError</td><td style="text-align:center;">TypeError</td><td style="text-align:center;">装箱转换</td><td style="text-align:center;">装箱转换</td><td style="text-align:center;">装箱转换</td><td style="text-align:center;">装箱转换</td><td style="text-align:center;">装箱转换</td><td style="text-align:center;">-</td></tr></tbody></table><p>因为 js 是弱类型语言，所以不同类型之间会进行类型转换，在使用<code>==</code>运算符的时候会发生非常多的隐式类型转换，并且规则极其复杂，所以大部分情况下我们会用<code>===</code>来进行比较，而不是<code>==</code></p><h3 id="stringtonumber"><a class="header-anchor" href="#stringtonumber" aria-hidden="true">#</a> StringToNumber</h3><ul><li>字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制 <ul><li>30</li><li>0b111</li><li>0o13</li><li>0xFF</li></ul></li><li>字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示 <ul><li>1e3</li><li>-1e-2</li></ul></li><li><code>parseInt</code>尽量写上第二个参数，一些浏览器会有诡异行为</li><li>多数情况下，<code>Number</code> 是比 <code>parseInt</code> 和 <code>parseFloat</code> 更好的选择</li></ul><h3 id="numbertostring"><a class="header-anchor" href="#numbertostring" aria-hidden="true">#</a> NumberToString</h3><ul><li>在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示</li><li>当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的</li></ul><h3 id="装箱转换"><a class="header-anchor" href="#装箱转换" aria-hidden="true">#</a> 装箱转换</h3><ul><li>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类</li><li>装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换</li><li>使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> symbolObject <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> symbolObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//object</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>symbolObject <span class="token keyword">instanceof</span> <span class="token class-name">Symbol</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>symbolObject<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Symbol<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>\n</code></pre></div><ul><li>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 <code>Object.prototype.toString</code> 获取，在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确</li></ul><h3 id="拆箱转换"><a class="header-anchor" href="#拆箱转换" aria-hidden="true">#</a> 拆箱转换</h3><ul><li>在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）</li><li>对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number</li><li>拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;valueOf&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;toString&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\no <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token comment">// valueOf</span>\n<span class="token comment">// toString</span>\n<span class="token comment">// TypeError</span>\n</code></pre></div><ul><li>到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o*2 换成 String(o)，那么你会看到调用顺序就变了</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;valueOf&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;toString&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token function">String</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// toString</span>\n<span class="token comment">// valueOf</span>\n<span class="token comment">// TypeError</span>\n</code></pre></div><ul><li>在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;valueOf&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;toString&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\no<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;toPrimitive&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// toPrimitive</span>\n<span class="token comment">// hello</span>\n</code></pre></div><h3 id="typeof"><a class="header-anchor" href="#typeof" aria-hidden="true">#</a> typeof</h3><ul><li>typeof 的运算结果，与运行时类型的规定有很多不一致的地方，下表列出了对应的结果 <table><thead><tr><th style="text-align:center;">示例表达式</th><th style="text-align:center;">typeof 结果</th><th style="text-align:center;">运行时类型</th></tr></thead><tbody><tr><td style="text-align:center;">null</td><td style="text-align:center;">object</td><td style="text-align:center;">Null</td></tr><tr><td style="text-align:center;">{}</td><td style="text-align:center;">object</td><td style="text-align:center;">Object</td></tr><tr><td style="text-align:center;">function(){}</td><td style="text-align:center;">function</td><td style="text-align:center;">Object</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">number</td><td style="text-align:center;">Number</td></tr><tr><td style="text-align:center;">&quot;ok&quot;</td><td style="text-align:center;">string</td><td style="text-align:center;">String</td></tr><tr><td style="text-align:center;">true</td><td style="text-align:center;">boolean</td><td style="text-align:center;">Boolean</td></tr><tr><td style="text-align:center;">void 0</td><td style="text-align:center;">undefined</td><td style="text-align:center;">Undefined</td></tr><tr><td style="text-align:center;">Symbol(&quot;a&quot;)</td><td style="text-align:center;">symbol</td><td style="text-align:center;">Symbol</td></tr></tbody></table></li><li>在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别</li><li>从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但 JavaScript 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机</li></ul><h2 id="js-对象的两类属性"><a class="header-anchor" href="#js-对象的两类属性" aria-hidden="true">#</a> js 对象的两类属性</h2><p>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）</p><h3 id="数据属性"><a class="header-anchor" href="#数据属性" aria-hidden="true">#</a> 数据属性</h3><ul><li>value：属性的值</li><li>writable：决定属性能否被赋值</li><li>enumerable：决定 for in 能否枚举该属性</li><li>configurable：决定该属性能否被删除或者改变特征值</li></ul><h3 id="访问器属性"><a class="header-anchor" href="#访问器属性" aria-hidden="true">#</a> 访问器属性</h3><ul><li>getter：函数或 undefined，在取属性值时被调用</li><li>setter：函数或 undefined，在设置属性值时被调用</li><li>enumerable：决定 for in 能否枚举该属性</li><li>configurable：决定该属性能否被删除或者改变特征值</li></ul><p>其中<code>writable</code>，<code>enumerable</code>,<code>configurable</code>默认都是<code>true</code>,用代码验证下：</p><div class="language-js"><pre><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\no<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token comment">//a 和 b 皆为数据属性</span>\nObject<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 1, writable: true, enumerable: true, configurable: true}</span>\nObject<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 2, writable: true, enumerable: true, configurable: true}</span>\n</code></pre></div><p>要改变其默认值，可以使用<code>Object.defineProperty</code></p><div class="language-js"><pre><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\nObject<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  value<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>\n  writable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n  enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n  configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">//a和b都是数据属性，但特征值变化了</span>\nObject<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 1, writable: true, enumerable: true, configurable: true}</span>\nObject<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 2, writable: false, enumerable: false, configurable: true}</span>\no<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n</code></pre></div><p>在创建对象的时候，可以使用 get 和 set 关键字来创建访问器属性</p><div class="language-js"><pre><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token keyword">get</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n</code></pre></div><p>访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数</p><h2 id="原型"><a class="header-anchor" href="#原型" aria-hidden="true">#</a> 原型</h2><ul><li>对象的私有字段<code>[[prototype]]</code>就是对象的原型</li><li>读一个属性，如果对象本身没有，会继续访问对象的原型，直到原型为空或者找到为止</li><li>ES6 以来，js 提供了一系列的内置函数，让我们更加方便的访问操作原型 <ul><li>Object.create:根据指定的原型创建新对象，原型可以是 null</li><li>Object.getPrototypeOf:获得一个对象的原型</li><li>Object.setPrototypeOf:设置一个对象的原型</li></ul></li></ul><h2 id="new-操作符做了那些事"><a class="header-anchor" href="#new-操作符做了那些事" aria-hidden="true">#</a> new 操作符做了那些事</h2><ul><li>以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象</li><li>将 this 和调用参数传给构造器并执行</li><li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象</li></ul><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> res <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> res <span class="token operator">:</span> obj<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token string">&quot;小明&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token string">&quot;小红&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>prototype <span class="token operator">===</span> b<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre></div><h2 id="js-中对象的分类"><a class="header-anchor" href="#js-中对象的分类" aria-hidden="true">#</a> js 中对象的分类</h2><h3 id="宿主对象"><a class="header-anchor" href="#宿主对象" aria-hidden="true">#</a> 宿主对象</h3><p>由 js 宿主环境提供，它们的行为完全有宿主环境决定</p><ul><li>浏览器环境：window</li><li>nodejs 环境：global</li></ul><h3 id="内置对象"><a class="header-anchor" href="#内置对象" aria-hidden="true">#</a> 内置对象</h3><p>js 提供的对象</p><ul><li>固有对象：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例 <blockquote><p>ECMA 为我们提供了 150+的固有对象，<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-well-known-intrinsic-objects" target="_blank" rel="noopener noreferrer">这里可以查看</a></p></blockquote></li><li>原生对象：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象 <table><thead><tr><th style="text-align:center;">基本类型</th><th style="text-align:center;">基础功能和数据结构</th><th style="text-align:center;">错误类型</th><th style="text-align:center;">二进制操作</th><th style="text-align:center;">带类型的数组</th></tr></thead><tbody><tr><td style="text-align:center;">Boolean</td><td style="text-align:center;">Array</td><td style="text-align:center;">Error</td><td style="text-align:center;">ArrayBuffer</td><td style="text-align:center;">Float32Array</td></tr><tr><td style="text-align:center;">String</td><td style="text-align:center;">Date</td><td style="text-align:center;">EvalError</td><td style="text-align:center;">ShareArrayBuffer</td><td style="text-align:center;">Float64Array</td></tr><tr><td style="text-align:center;">Number</td><td style="text-align:center;">RegExp</td><td style="text-align:center;">RangeError</td><td style="text-align:center;">DataView</td><td style="text-align:center;">Int8Array</td></tr><tr><td style="text-align:center;">Symbol</td><td style="text-align:center;">Promise</td><td style="text-align:center;">ReferenceError</td><td style="text-align:center;"></td><td style="text-align:center;">Int16Array</td></tr><tr><td style="text-align:center;">Object</td><td style="text-align:center;">Proxy</td><td style="text-align:center;">SyntaxError</td><td style="text-align:center;"></td><td style="text-align:center;">Int32Array</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">Map</td><td style="text-align:center;">TypeError</td><td style="text-align:center;"></td><td style="text-align:center;">UInt8Array</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">WeakMap</td><td style="text-align:center;">URIError</td><td style="text-align:center;"></td><td style="text-align:center;">UInt16Array</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">Set</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">UInt32Array</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">WeakSet</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">UInt8ClampedArray</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">Function</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table></li><li>普通对象：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承</li><li>特殊行为的对象 <ul><li>Array：Array 的 length 属性根据最大的下标自动发生变化</li><li>Object.prototype:作为所有正常对象的默认原型，不能给它设置原型</li><li>String：为了支持下标运算，String 的正整数属性访问会去字符串里面查找</li><li>Arguments：Arguments 的非负整数型下标属性跟对应的变量联动</li><li>模块的 namespace 对象：特殊的地方非常多，跟普通的对象完全不一样，尽量只用于 import</li><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊</li><li>bind 后的 function：跟原来的函数相关联</li></ul></li></ul><h2 id="事件循环"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h2><p>运行机制不同于<a href="./nodejs.html#事件循环">node 环境</a></p><h3 id="宏观任务（macrotask）"><a class="header-anchor" href="#宏观任务（macrotask）" aria-hidden="true">#</a> 宏观任务（macrotask）</h3><ul><li>script 整体代码</li><li>setTimeout/setInterval</li><li>I/O 操作</li><li>UI 渲染</li></ul><h3 id="微观任务（microtask）"><a class="header-anchor" href="#微观任务（microtask）" aria-hidden="true">#</a> 微观任务（microtask）</h3><ul><li>promise</li><li>MutationObserver</li><li>执行时机：microtask 在事件循环的 macrotask 执行完之后执行</li></ul><h2 id="es-模块机制"><a class="header-anchor" href="#es-模块机制" aria-hidden="true">#</a> ES 模块机制</h2><h3 id="import"><a class="header-anchor" href="#import" aria-hidden="true">#</a> import</h3><div class="language-js"><pre><code><span class="token comment">// 编译时执行（静态执行）</span>\n<span class="token comment">// import 语句会执行所加载的模块，如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次</span>\n\n<span class="token comment">// 仅执行，不输入</span>\n<span class="token keyword">import</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 具名导入</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 全部导入</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> nickname <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 匿名导入</span>\n<span class="token keyword">import</span> name <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n<span class="token comment">// 等同于</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> name <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 匿名和具名一起导入</span>\n<span class="token keyword">import</span> _<span class="token punctuation">,</span> <span class="token punctuation">{</span> each<span class="token punctuation">,</span> forEach <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;lodash&quot;</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="export"><a class="header-anchor" href="#export" aria-hidden="true">#</a> export</h3><div class="language-js"><pre><code><span class="token comment">// 必须导出一个接口，而不能是一个值</span>\n<span class="token comment">// 导出的是值的引用，相当于是动态绑定的，即可以用 setTimeout 延迟改变导出的值，导入的值也会发生变化</span>\n\n<span class="token comment">// 具名导出</span>\n<span class="token comment">// 第一种</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">&quot;Scott&quot;</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 第二种</span>\n<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">&quot;Scott&quot;</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 匿名导出</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> name<span class="token punctuation">;</span>\n<span class="token comment">// 等同于</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> name <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="复合写法"><a class="header-anchor" href="#复合写法" aria-hidden="true">#</a> 复合写法</h3><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token punctuation">{</span> es6 <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> es6 <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">as</span> es6 <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>\n</code></pre></div><h2 id="闭包"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><p>闭包就是一个能够读取其他函数内部变量的函数</p><div class="language-js"><pre><code><span class="token comment">//这样就形成了闭包</span>\n<span class="token keyword">function</span> <span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token string">&quot;这是函数内部的变量&quot;</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> state<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="执行上下文"><a class="header-anchor" href="#执行上下文" aria-hidden="true">#</a> 执行上下文</h2><p>任何语句的执行都依赖上下文，不同的上下文语句效果会发生改变</p><h3 id="es3"><a class="header-anchor" href="#es3" aria-hidden="true">#</a> ES3</h3><ul><li>scope：作用域，也常常被叫做作用域链</li><li>variable object：变量对象，用于存储变量的对象</li><li>this value：this 值</li></ul><h3 id="es5"><a class="header-anchor" href="#es5" aria-hidden="true">#</a> ES5</h3><ul><li>lexical environment：词法环境，当获取变量时使用</li><li>variable environment：变量环境，当声明变量时使用</li><li>this value：this 值</li></ul><h3 id="es7"><a class="header-anchor" href="#es7" aria-hidden="true">#</a> ES7</h3><ul><li>lexical environment：词法环境，当获取变量或者 this 值时使用</li><li>variable environment：变量环境，当声明变量时使用</li><li>code evaluation state：用于恢复代码执行位置</li><li>Function：执行的任务是函数时使用，表示正在被执行的函数</li><li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码</li><li>Realm：使用的基础库和内置对象实例</li><li>Generator：仅生成器上下文有这个属性，表示当前生成器</li><li>IIFE(立即执行函数)</li></ul><h2 id="控制型语句一些组合行为"><a class="header-anchor" href="#控制型语句一些组合行为" aria-hidden="true">#</a> 控制型语句一些组合行为</h2><table><thead><tr><th></th><th>break</th><th>continue</th><th>return</th><th>throw</th></tr></thead><tbody><tr><td>if</td><td>穿透</td><td>穿透</td><td>穿透</td><td>穿透</td></tr><tr><td>switch</td><td>消费</td><td>穿透</td><td>穿透</td><td>穿透</td></tr><tr><td>for/while</td><td>消费</td><td>消费</td><td>穿透</td><td>穿透</td></tr><tr><td>function</td><td>报错</td><td>报错</td><td>消费</td><td>穿透</td></tr><tr><td>try</td><td>特殊处理</td><td>特殊处理</td><td>特殊处理</td><td>消费</td></tr><tr><td>catch</td><td>特殊处理</td><td>特殊处理</td><td>特殊处理</td><td>穿透</td></tr><tr><td>finally</td><td>特殊处理</td><td>特殊处理</td><td>特殊处理</td><td>穿透</td></tr></tbody></table><h2 id="javascript-的词法定义"><a class="header-anchor" href="#javascript-的词法定义" aria-hidden="true">#</a> JavaScript 的词法定义</h2><ul><li>WhiteSpace 空白字符</li><li>LineTerminator 换行符</li><li>Comment 注释</li><li>Token 词 <ul><li>IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了</li><li>Punctuator 符号，我们使用的运算符和大括号等符号</li><li>NumericLiteral 数字直接量，就是我们写的数字</li><li>StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量</li><li>Template 字符串模板，用反引号` 括起来的直接量</li></ul></li></ul>',92);e.render=function(a,s,e,p,l,c){return n(),t("div",null,[o])};export default e;export{s as __pageData};
