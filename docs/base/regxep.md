## 正则表达式是什么

检索替换字符串的一套规则

## 元字符

```js
\ 转义符

\d [0-9]

\D 非数字

\s 空格

\S 非空格

\w 字符（数字、字母、_）

\W 非\w所匹配范围

\b 单词边界，就是指单词和空格之间的位置（单词边界，单词起始、结束，连词符(除了\w之外的所有的字符都属于连词符)）

\B 非\b部分

.  除了换行符(\n、\r)之外的所有的字符都是它匹配范围

^  字符串的起始  ^符在范围词里面代表的是'非'的意思

$  字符串的结束
```

## 量词

```js
量词:默认情况是贪婪匹配，以最高次匹配，如果不成功就依次降低次数，直到到最低次

{最小次,最大次}
{5,10}
{5,}  最少五次，最高无穷大

{0,}  对应 *号  表示0次或多次
{1,}  对应 +号  表示1次或多次
{0,1} 对应 ?号  表示0次或1次，可有可无

非贪婪匹配:量词之后跟问号，代表非贪婪，以最少次匹配
```

## 标识符

```js
i  忽略大小写

g  全局匹配  这个标识符要慎用,因为它会改变正则对象的lastIndex属性

m  多行匹配  此标识符只会在使用^和$的正则表达式中才可能有效
```

```js
//全局标识符g会改变lastIndex从而改变下面的结果
let str = "11112223333333";
let reg = /\d+/g;
console.log(reg.lastIndex); //0
console.log(reg.test(str)); //true
console.log(reg.lastIndex); //14
console.log(reg.test(str)); //false
console.log(reg.lastIndex); //0

// 解决办法，在对应的地方手动重置为0
reg.lastIndex = 0;
```

## 子集

```js
子集 ()

被圆括号包裹的部分属于一个整体(子集)

$1 - $n  对应的是正则里面匹配的子集 第一个就是$1 依次类推
```

```js
//子集$的应用
let str = "第一段第二段";
let reg = /(第一段)(第二段)/g;
let s2 = str.replace(reg, "$2$1");
console.log(s2); // 第二段第一段
```

## 范围词

```js
范围词 []

范围词里所有的字符串都是或者关系

[0-9] ==> \d  0123456789

[a-zA-Z] ==> 英文字母

[\u4e00-\u9fa5] ==> 中文汉字的Unicode编码

|  要想在多个不同的范围词之间用或者关系用 | 符号,不同范围词用子集来表示一个整体
```

## 断言

```js
子集不捕获匹配  (?:模式) 子集默认是捕获匹配

正向肯定预查 (?=模式)

正向否定预查 (?!模式)

反向肯定预查(?<=模式)

反向否定预查(?<!模式)
```

```js
//正向肯定预查的应用 正向否定预查结果相反
let str1 = "test123";
let str2 = "test456";
let reg = /test(?=123)/; //如果尾数是123就要 否则就不要
console.log(reg.test(str1)); //true
console.log(reg.test(str2)); //false

//反向肯定预查的应用 反向否定预查结果相反
let str3 = "123test";
let str4 = "456test";
let reg1 = /(?<=123)test/;
console.log(reg1.test(str3)); //true
console.log(reg1.test(str4)); //false
```

## 一些特殊的符号

```js
\t 水平制表符

\v 垂直制表符

\f 换页符

\n 换行符

\r 回车符
```

## \1 的应用

```js
//  \1的应用 匹配相同且重复的内容 必须在有子集出现的情况下才能用
let str = "1111222333";
let reg = /(\d)\1+/g;
console.log(str.match(reg)); // ['1111','222','333']
```
